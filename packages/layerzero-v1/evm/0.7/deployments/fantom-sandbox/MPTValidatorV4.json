{
  "address": "0x389b1a252383a3f9D3061a24EE075DCCa627f0ef",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_stargateBridgeAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_stgTokenAddress",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "_localChainId",
          "type": "uint16"
        },
        {
          "internalType": "address",
          "name": "_ulnAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "PACKET_SIGNATURE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "dstChainId",
              "type": "uint16"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "dstAddress",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "srcAddress",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "ulnAddress",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "payload",
              "type": "bytes"
            }
          ],
          "internalType": "struct LayerZeroPacket.Packet",
          "name": "packet",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "blockHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "receiptsRoot",
          "type": "bytes32"
        }
      ],
      "name": "assertMessagePath",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "uint16",
          "name": "srcChain",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "sizeOfSrcAddress",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "ulnAddress",
          "type": "bytes32"
        }
      ],
      "name": "getPacket",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "dstChainId",
              "type": "uint16"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "dstAddress",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "srcAddress",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "ulnAddress",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "payload",
              "type": "bytes"
            }
          ],
          "internalType": "struct LayerZeroPacket.Packet",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getUtilsVersion",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "hashRoot",
          "type": "bytes32"
        },
        {
          "internalType": "uint256[]",
          "name": "receiptSlotIndex",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "logIndex",
          "type": "uint256"
        },
        {
          "internalType": "bytes[]",
          "name": "proof",
          "type": "bytes[]"
        }
      ],
      "name": "getVerifyLog",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "contractAddress",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "topicZeroSig",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct IValidationLibraryHelper.ULNLog",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "localChainId",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_payload",
          "type": "bytes"
        }
      ],
      "name": "secureStgPayload",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_payload",
          "type": "bytes"
        }
      ],
      "name": "secureStgTokenPayload",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stargateBridgeAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stgTokenAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "uln",
      "outputs": [
        {
          "internalType": "contract IUltraLightNode",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "utilsVersion",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_receiptsRoot",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_transactionProof",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_remoteAddressSize",
          "type": "uint256"
        }
      ],
      "name": "validateProof",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "dstChainId",
              "type": "uint16"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "dstAddress",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "srcAddress",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "ulnAddress",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "payload",
              "type": "bytes"
            }
          ],
          "internalType": "struct LayerZeroPacket.Packet",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x1fa342a898018b96bf17ddd33ae590c30a0ca42a71506cf25969ce837aaab01e",
  "receipt": {
    "to": null,
    "from": "0x732BC218Ea380B93081c7dfeb362A13e28b7A8d6",
    "contractAddress": "0x389b1a252383a3f9D3061a24EE075DCCa627f0ef",
    "transactionIndex": 0,
    "gasUsed": "2182933",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x000029e000000338853fe8a7cf5ba6c59066f656db12a1e9f58d4af1997e8d54",
    "transactionHash": "0x1fa342a898018b96bf17ddd33ae590c30a0ca42a71506cf25969ce837aaab01e",
    "logs": [],
    "blockNumber": 9991088,
    "cumulativeGasUsed": "2182933",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x0000000000000000000000000000000000000000",
    "0x0000000000000000000000000000000000000000",
    20012,
    "0xc92d3Dd74A824C7aAEEa36e7A41Fcc9d42370a9a"
  ],
  "numDeployments": 1,
  "solcInputHash": "721153c11c12094ffa795700e08c99d4",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stargateBridgeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stgTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_localChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_ulnAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PACKET_SIGNATURE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"ulnAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct LayerZeroPacket.Packet\",\"name\":\"packet\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"receiptsRoot\",\"type\":\"bytes32\"}],\"name\":\"assertMessagePath\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"srcChain\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"sizeOfSrcAddress\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ulnAddress\",\"type\":\"bytes32\"}],\"name\":\"getPacket\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"ulnAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct LayerZeroPacket.Packet\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUtilsVersion\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"receiptSlotIndex\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"logIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"proof\",\"type\":\"bytes[]\"}],\"name\":\"getVerifyLog\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"contractAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"topicZeroSig\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IValidationLibraryHelper.ULNLog\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localChainId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"secureStgPayload\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"secureStgTokenPayload\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stargateBridgeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stgTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uln\",\"outputs\":[{\"internalType\":\"contract IUltraLightNode\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utilsVersion\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_receiptsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_transactionProof\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_remoteAddressSize\",\"type\":\"uint256\"}],\"name\":\"validateProof\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"ulnAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct LayerZeroPacket.Packet\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MPTValidatorV4.sol\":\"MPTValidatorV4\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xe22a1fc7400ae196eba2ad1562d0386462b00a6363b742d55a2fd2021a58586f\",\"license\":\"MIT\"},\"contracts/MPTValidatorV4.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./interfaces/IValidationLibraryHelper.sol\\\";\\nimport \\\"./utility/LayerZeroPacket.sol\\\";\\nimport \\\"./utility/UltraLightNodeEVMDecoder.sol\\\";\\n\\ninterface IUltraLightNode {\\n    struct BlockData {\\n        uint confirmations;\\n        bytes32 data;\\n    }\\n\\n    struct ApplicationConfiguration {\\n        uint16 inboundProofLibraryVersion;\\n        uint64 inboundBlockConfirmations;\\n        address relayer;\\n        uint16 outboundProofType;\\n        uint64 outboundBlockConfirmations;\\n        address oracle;\\n    }\\n\\n    function getAppConfig(uint16 _chainId, address userApplicationAddress) external view returns (ApplicationConfiguration memory);\\n    function getBlockHeaderData(address _oracle, uint16 _remoteChainId, bytes32 _lookupHash) external view returns (BlockData memory blockData);\\n}\\n\\ninterface IStargate {\\n    // Stargate objects for abi encoding / decoding\\n    struct SwapObj {\\n        uint256 amount;\\n        uint256 eqFee;\\n        uint256 eqReward;\\n        uint256 lpFee;\\n        uint256 protocolFee;\\n        uint256 lkbRemove;\\n    }\\n\\n    struct CreditObj {\\n        uint256 credits;\\n        uint256 idealBalance;\\n    }\\n}\\n\\ncontract MPTValidatorV4 is ILayerZeroValidationLibrary, IValidationLibraryHelper {\\n    using RLPDecode for RLPDecode.RLPItem;\\n    using RLPDecode for RLPDecode.Iterator;\\n    using LayerZeroPacket for bytes;\\n\\n    uint8 public utilsVersion = 3;\\n    bytes32 public constant PACKET_SIGNATURE = 0xe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6;\\n\\n    address immutable public stargateBridgeAddress;\\n    address immutable public stgTokenAddress;\\n    uint16 immutable public localChainId;\\n    IUltraLightNode immutable public uln;\\n\\n    constructor (address _stargateBridgeAddress, address _stgTokenAddress, uint16 _localChainId, address _ulnAddress) {\\n        stargateBridgeAddress = _stargateBridgeAddress;\\n        stgTokenAddress = _stgTokenAddress;\\n        localChainId = _localChainId;\\n        uln = IUltraLightNode(_ulnAddress);\\n    }\\n\\n    function validateProof(bytes32 _receiptsRoot, bytes calldata _transactionProof, uint _remoteAddressSize) external view override returns (LayerZeroPacket.Packet memory) {\\n        require(_remoteAddressSize > 0, \\\"ProofLib: invalid address size\\\");\\n\\n        (uint16 remoteChainId, bytes32 blockHash, bytes[] memory proof, uint[] memory receiptSlotIndex, uint logIndex) = abi.decode(_transactionProof, (uint16, bytes32, bytes[], uint[], uint));\\n\\n        ULNLog memory log = _getVerifiedLog(_receiptsRoot, receiptSlotIndex, logIndex, proof);\\n        require(log.topicZeroSig == PACKET_SIGNATURE, \\\"ProofLib: packet not recognized\\\"); //data\\n\\n        LayerZeroPacket.Packet memory packet = log.data.getPacket(remoteChainId, _remoteAddressSize, log.contractAddress);\\n\\n        _assertMessagePath(packet, blockHash, _receiptsRoot);\\n\\n        if (packet.dstAddress == stargateBridgeAddress) packet.payload = _secureStgPayload(packet.payload);\\n\\n        if (packet.dstAddress == stgTokenAddress) packet.payload = _secureStgTokenPayload(packet.payload);\\n\\n        return packet;\\n    }\\n\\n    function _assertMessagePath(LayerZeroPacket.Packet memory packet, bytes32 blockHash, bytes32 receiptsRoot) internal view {\\n        require(packet.dstChainId == localChainId, \\\"ProofLib: invalid destination chain ID\\\");\\n\\n        IUltraLightNode.ApplicationConfiguration memory appConfig = uln.getAppConfig(packet.srcChainId, packet.dstAddress);\\n        IUltraLightNode.BlockData memory blockData = uln.getBlockHeaderData(appConfig.oracle, packet.srcChainId, blockHash);\\n\\n        require(blockData.data == receiptsRoot, \\\"ProofLib: invalid receipt root\\\");\\n\\n        require(blockData.confirmations >= appConfig.inboundBlockConfirmations, \\\"ProofLib: not enough block confirmations\\\");\\n    }\\n\\n    function _secureStgTokenPayload(bytes memory _payload) internal pure returns (bytes memory) {\\n        (bytes memory toAddressBytes, uint256 qty) = abi.decode(_payload, (bytes, uint256));\\n\\n        address toAddress = address(0);\\n        if (toAddressBytes.length > 0) {\\n            assembly { toAddress := mload(add(toAddressBytes, 20))}\\n        }\\n\\n        if (toAddress == address(0)) {\\n            address deadAddress = address(0x000000000000000000000000000000000000dEaD);\\n            bytes memory newToAddressBytes = abi.encodePacked(deadAddress);\\n            return abi.encode(newToAddressBytes, qty);\\n        }\\n\\n        // default to return the original payload\\n        return _payload;\\n    }\\n\\n    function _secureStgPayload(bytes memory _payload) internal view returns (bytes memory) {\\n        // functionType is uint8 even though the encoding will take up the side of uint256\\n        uint8 functionType;\\n        assembly { functionType := mload(add(_payload, 32)) }\\n\\n        // TYPE_SWAP_REMOTE == 1 && only if the payload has a payload\\n        // only swapRemote inside of stargate can call sgReceive on an user supplied to address\\n        // thus we do not care about the other type functions even if the toAddress is overly long.\\n        if (functionType == 1) {\\n            // decode the _payload with its types\\n            (\\n                ,\\n                uint256 srcPoolId,\\n                uint256 dstPoolId,\\n                uint256 dstGasForCall,\\n                IStargate.CreditObj memory c,\\n                IStargate.SwapObj memory s,\\n                bytes memory toAddressBytes,\\n                bytes memory contractCallPayload\\n            ) = abi.decode(_payload, (uint8, uint256, uint256, uint256, IStargate.CreditObj, IStargate.SwapObj, bytes, bytes));\\n\\n            // if contractCallPayload.length > 0 need to check if the to address is a contract or not\\n            if (contractCallPayload.length > 0) {\\n                // otherwise, need to check if the payload can be delivered to the toAddress\\n                address toAddress = address(0);\\n                if (toAddressBytes.length > 0) {\\n                    assembly { toAddress := mload(add(toAddressBytes, 20)) }\\n                }\\n\\n                // check if the toAddress is a contract. We are not concerned about addresses that pretend to be wallets. because worst case we just delete their payload if being malicious\\n                // we can guarantee that if a size > 0, then the contract is definitely a contract address in this context\\n                uint size;\\n                assembly { size := extcodesize(toAddress) }\\n\\n                if (size == 0) {\\n                    // size == 0 indicates its not a contract, payload wont be delivered\\n                    // secure the _payload to make sure funds can be delivered to the toAddress\\n                    bytes memory newToAddressBytes = abi.encodePacked(toAddress);\\n                    bytes memory securePayload = abi.encode(functionType, srcPoolId, dstPoolId, dstGasForCall, c, s, newToAddressBytes, bytes(\\\"\\\"));\\n                    return securePayload;\\n                }\\n            }\\n        }\\n\\n        // default to return the original payload\\n        return _payload;\\n    }\\n\\n    function secureStgTokenPayload(bytes memory _payload) external pure returns(bytes memory) {\\n        return _secureStgTokenPayload(_payload);\\n    }\\n\\n    function secureStgPayload(bytes memory _payload) external view returns(bytes memory) {\\n        return _secureStgPayload(_payload);\\n    }\\n\\n    function _getVerifiedLog(bytes32 hashRoot, uint[] memory paths, uint logIndex, bytes[] memory proof) internal pure returns(ULNLog memory) {\\n        require(paths.length == proof.length, \\\"ProofLib: invalid proof size\\\");\\n        require(proof.length >0, \\\"ProofLib: proof size must > 0\\\");\\n        RLPDecode.RLPItem memory item;\\n        bytes memory proofBytes;\\n\\n        for (uint i = 0; i < proof.length; i++) {\\n            proofBytes = proof[i];\\n            require(hashRoot == keccak256(proofBytes), \\\"ProofLib: invalid hashlink\\\");\\n            item = RLPDecode.toRlpItem(proofBytes).safeGetItemByIndex(paths[i]);\\n            if (i < proof.length - 1) hashRoot = bytes32(item.toUint());\\n        }\\n\\n        // burning status + gasUsed + logBloom\\n        RLPDecode.RLPItem memory logItem = item.typeOffset().safeGetItemByIndex(3);\\n        RLPDecode.Iterator memory it =  logItem.safeGetItemByIndex(logIndex).iterator();\\n        ULNLog memory log;\\n        log.contractAddress = bytes32(it.next().toUint());\\n        log.topicZeroSig = bytes32(it.next().safeGetItemByIndex(0).toUint());\\n        log.data = it.next().toBytes();\\n\\n        return log;\\n    }\\n\\n    function getUtilsVersion() external override view returns(uint8) {\\n        return utilsVersion;\\n    }\\n\\n    function getVerifyLog(bytes32 hashRoot, uint[] memory receiptSlotIndex, uint logIndex, bytes[] memory proof) external override pure returns(ULNLog memory){\\n        return _getVerifiedLog(hashRoot, receiptSlotIndex, logIndex, proof);\\n    }\\n\\n    function getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) external override pure returns(LayerZeroPacket.Packet memory){\\n        return data.getPacket(srcChain, sizeOfSrcAddress, ulnAddress);\\n    }\\n\\n    // profiling and test\\n    function assertMessagePath(LayerZeroPacket.Packet memory packet, bytes32 blockHash, bytes32 receiptsRoot) external view {\\n        _assertMessagePath(packet, blockHash, receiptsRoot);\\n    }\\n}\\n\",\"keccak256\":\"0xb8506be038402086a387a389ac99fa22e578367612d5ff56afa9f6057401f789\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ILayerZeroValidationLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../utility/LayerZeroPacket.sol\\\";\\n\\ninterface ILayerZeroValidationLibrary {\\n    function validateProof(bytes32 blockData, bytes calldata _data, uint _remoteAddressSize) external returns (LayerZeroPacket.Packet memory packet);\\n}\\n\",\"keccak256\":\"0x8143e501d169a928c580c4aed06d67438d4ae5689ba9516c0a32b55b2aaf4e96\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IValidationLibraryHelper.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../utility/LayerZeroPacket.sol\\\";\\nimport \\\"./ILayerZeroValidationLibrary.sol\\\";\\n\\ninterface IValidationLibraryHelper {\\n    struct ULNLog{\\n        bytes32 contractAddress;\\n        bytes32 topicZeroSig;\\n        bytes data;\\n    }\\n\\n    function getVerifyLog(bytes32 hashRoot, uint[] memory receiptSlotIndex, uint logIndex, bytes[] memory proof) external pure returns(ULNLog memory);\\n    function getPacket(bytes memory data, uint16 srcChain, uint sizeOfSrcAddress, bytes32 ulnAddress) external pure returns(LayerZeroPacket.Packet memory);\\n    function getUtilsVersion() external view returns(uint8);\\n}\\n\",\"keccak256\":\"0x40033cf7ccff290e714e4747436ead52a3c5fa3f12fbdf7644c95bcf6e3139e1\",\"license\":\"BUSL-1.1\"},\"contracts/utility/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-2-Clause\\n// https://github.com/ensdomains/buffer\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev A library for working with mutable byte buffers in Solidity.\\n *\\n * Byte buffers are mutable and expandable, and provide a variety of primitives\\n * for writing to them. At any time you can fetch a bytes object containing the\\n * current contents of the buffer. The bytes object should not be stored between\\n * operations, as it may change due to resizing of the buffer.\\n */\\nlibrary Buffer {\\n    /**\\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n     *      a capacity. The capacity may be longer than the current value, in\\n     *      which case it can be extended without the need to allocate more memory.\\n     */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n     * @dev Initializes a buffer with an initial capacity.a co\\n     * @param buf The buffer to initialize.\\n     * @param capacity The number of bytes of space to allocate the buffer.\\n     * @return The buffer, for chaining.\\n     */\\n    function init(buffer memory buf, uint capacity) internal pure returns (buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            mstore(0x40, add(32, add(ptr, capacity)))\\n        }\\n        return buf;\\n    }\\n\\n\\n    /**\\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n     *      the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param off The start offset to write to.\\n     * @param rawData The data to append.\\n     * @param len The number of bytes to copy.\\n     * @return The original buffer, for chaining.\\n     */\\n    function writeRawBytes(\\n        buffer memory buf,\\n        uint off,\\n        bytes memory rawData,\\n        uint offData,\\n        uint len\\n    ) internal pure returns (buffer memory) {\\n        if (off + len > buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(add(len, off), buflen) {\\n                mstore(bufptr, add(len, off))\\n            }\\n            src := add(rawData, offData)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256**(32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n     *      the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param off The start offset to write to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to copy.\\n     * @return The original buffer, for chaining.\\n     */\\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns (buffer memory) {\\n        require(len <= data.length);\\n\\n        if (off + len > buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n        // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n        // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n        // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n        // Update buffer length if we're extending it\\n            if gt(add(len, off), buflen) {\\n                mstore(bufptr, add(len, off))\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256**(32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n\\n        return buf;\\n    }\\n\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, data.length);\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    function max(uint a, uint b) private pure returns (uint) {\\n        if (a > b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n}\\n\",\"keccak256\":\"0x4fb738133f8453cd2d28d530ee66b3b45a7969ba6372c008bcb0479fa3f6e8f9\",\"license\":\"BSD-2-Clause\"},\"contracts/utility/LayerZeroPacket.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Buffer.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary LayerZeroPacket {\\n    using Buffer for Buffer.buffer;\\n    using SafeMath for uint;\\n\\n    struct Packet {\\n        uint16 srcChainId;\\n        uint16 dstChainId;\\n        uint64 nonce;\\n        address dstAddress;\\n        bytes srcAddress;\\n        bytes32 ulnAddress;\\n        bytes payload;\\n    }\\n\\n    function getPacket(\\n        bytes memory data,\\n        uint16 srcChain,\\n        uint sizeOfSrcAddress,\\n        bytes32 ulnAddress\\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\\n        uint16 dstChainId;\\n        address dstAddress;\\n        uint size;\\n        uint64 nonce;\\n\\n        // The log consists of the destination chain id and then a bytes payload\\n        //      0--------------------------------------------31\\n        // 0   |  total bytes size\\n        // 32  |  destination chain id\\n        // 64  |  bytes offset\\n        // 96  |  bytes array size\\n        // 128 |  payload\\n        assembly {\\n            dstChainId := mload(add(data, 32))\\n            size := mload(add(data, 96)) /// size of the byte array\\n            nonce := mload(add(data, 104)) // offset to convert to uint64  128  is index -24\\n            dstAddress := mload(add(data, sub(add(128, sizeOfSrcAddress), 4))) // offset to convert to address 12 -8\\n        }\\n\\n        Buffer.buffer memory srcAddressBuffer;\\n        srcAddressBuffer.init(sizeOfSrcAddress);\\n        srcAddressBuffer.writeRawBytes(0, data, 136, sizeOfSrcAddress); // 128 + 8\\n\\n        uint payloadSize = size.sub(28).sub(sizeOfSrcAddress);\\n        Buffer.buffer memory payloadBuffer;\\n        payloadBuffer.init(payloadSize);\\n        payloadBuffer.writeRawBytes(0, data, sizeOfSrcAddress.add(156), payloadSize); // 148 + 8\\n        return LayerZeroPacket.Packet(srcChain, dstChainId, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\\n    }\\n\\n    function getPacketV2(\\n        bytes memory data,\\n        uint sizeOfSrcAddress,\\n        bytes32 ulnAddress\\n    ) internal pure returns (LayerZeroPacket.Packet memory) {\\n        // packet def: abi.encodePacked(nonce, srcChain, srcAddress, dstChain, dstAddress, payload);\\n        //              if from EVM\\n        // 0 - 31       0 - 31          |  total bytes size\\n        // 32 - 39      32 - 39         |  nonce\\n        // 40 - 41      40 - 41         |  srcChainId\\n        // 42 - P       42 - 61         |  srcAddress, where P = 41 + sizeOfSrcAddress,\\n        // P - P+1      62 - 63         |  dstChainId\\n        // P+2 - P+21   64 - 83         |  dstAddress\\n        // P+22 - END   84 - END        |  payload\\n\\n        // decode the packet\\n        uint256 realSize;\\n        uint64 nonce;\\n        uint16 srcChain;\\n        uint16 dstChain;\\n        address dstAddress;\\n        assembly {\\n            realSize := mload(add(data, 64)) //48 - 32 + 64\\n            nonce := mload(add(data, 72)) // 40 - 32 + 64\\n            srcChain := mload(add(data, 74)) // 42 - 32 + 64\\n            dstChain := mload(add(data, add(76, sizeOfSrcAddress))) // 42 + sizeOfSrcAddress + 2 - 32 + 64\\n            dstAddress := mload(add(data, add(96, sizeOfSrcAddress))) // 42 + sizeOfSrcAddress + 2 + 20 - 32 + 64\\n        }\\n\\n        require(srcChain != 0, \\\"LayerZeroPacket: invalid packet\\\");\\n\\n        Buffer.buffer memory srcAddressBuffer;\\n        srcAddressBuffer.init(sizeOfSrcAddress);\\n        srcAddressBuffer.writeRawBytes(0, data, 106, sizeOfSrcAddress);\\n\\n        uint nonPayloadSize = sizeOfSrcAddress.add(32);// 2 + 2 + 8 + 20, 32 + 20 = 52 if sizeOfSrcAddress == 20\\n        uint payloadSize = realSize.sub(nonPayloadSize);\\n        Buffer.buffer memory payloadBuffer;\\n        payloadBuffer.init(payloadSize);\\n        payloadBuffer.writeRawBytes(0, data, nonPayloadSize.add(96), payloadSize); // 52 + 32  + 64\\n\\n        return LayerZeroPacket.Packet(srcChain, dstChain, nonce, dstAddress, srcAddressBuffer.buf, ulnAddress, payloadBuffer.buf);\\n    }\\n}\\n\",\"keccak256\":\"0x24beaf39e1005b90e7ef7656143811ba98ab88f65d58e8748016cacde27a37fd\",\"license\":\"BUSL-1.1\"},\"contracts/utility/RLPDecode.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// https://github.com/hamdiallam/solidity-rlp\\n\\npragma solidity ^0.7.0;\\n\\nlibrary RLPDecode {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint len;\\n        uint memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self), \\\"RLPDecoder iterator has no next\\\");\\n\\n        uint ptr = self.nextPtr;\\n        uint itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n        // offset the pointer if the first byte\\n\\n        uint8 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n        uint len = item.length;\\n        if (len > 0 && byte0 < LIST_SHORT_START) {\\n            assembly {\\n                memPtr := add(memPtr, 0x01)\\n            }\\n            len -= 1;\\n        }\\n        return RLPItem(len, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self), \\\"RLPDecoder iterator is not list\\\");\\n\\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\\n        uint offset = _payloadOffset(item.memPtr);\\n        require(item.len >= offset, \\\"RLPDecoder: invalid uint RLP item offset size\\\");\\n        return item.len - offset;\\n    }\\n\\n    /*\\n     * @param item RLP encoded list in bytes\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item), \\\"RLPDecoder iterator is not a list\\\");\\n\\n        uint items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint dataLen;\\n        for (uint i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    /*\\n     * @param get the RLP item by index. save gas.\\n     */\\n    function getItemByIndex(RLPItem memory item, uint idx) internal pure returns (RLPItem memory) {\\n        require(isList(item), \\\"RLPDecoder iterator is not a list\\\");\\n\\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint dataLen;\\n        for (uint i = 0; i < idx; i++) {\\n            dataLen = _itemLength(memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n        dataLen = _itemLength(memPtr);\\n        return RLPItem(dataLen, memPtr);\\n    }\\n\\n\\n    /*\\n     * @param get the RLP item by index. save gas.\\n     */\\n    function safeGetItemByIndex(RLPItem memory item, uint idx) internal pure returns (RLPItem memory) {\\n        require(isList(item), \\\"RLPDecoder iterator is not a list\\\");\\n        require(idx < numItems(item), \\\"RLP item out of bounds\\\");\\n        uint endPtr = item.memPtr + item.len;\\n\\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint dataLen;\\n        for (uint i = 0; i < idx; i++) {\\n            dataLen = _itemLength(memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n        dataLen = _itemLength(memPtr);\\n\\n        require(memPtr + dataLen <= endPtr, \\\"RLP item overflow\\\");\\n        return RLPItem(dataLen, memPtr);\\n    }\\n\\n    /*\\n     * @param offset the receipt bytes item\\n     */\\n    function typeOffset(RLPItem memory item) internal pure returns (RLPItem memory) {\\n        uint offset = _payloadOffset(item.memPtr);\\n        uint8 byte0;\\n        uint memPtr = item.memPtr;\\n        uint len = item.len;\\n        assembly {\\n            memPtr := add(memPtr, offset)\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n        if (len >0 && byte0 < LIST_SHORT_START) {\\n            assembly {\\n                memPtr := add(memPtr, 0x01)\\n            }\\n            len -= 1;\\n        }\\n        return RLPItem(len, memPtr);\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1, \\\"RLPDecoder toBoolean invalid length\\\");\\n        uint result;\\n        uint memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21, \\\"RLPDecoder toAddress invalid length\\\");\\n\\n        return address(toUint(item));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint) {\\n        require(item.len > 0 && item.len <= 33, \\\"RLPDecoder toUint invalid length\\\");\\n\\n        uint offset = _payloadOffset(item.memPtr);\\n        require(item.len >= offset, \\\"RLPDecoder: invalid RLP item offset size\\\");\\n        uint len = item.len - offset;\\n\\n        uint result;\\n        uint memPtr = item.memPtr + offset;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if necessary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\\n        // one byte prefix\\n        require(item.len == 33, \\\"RLPDecoder toUintStrict invalid length\\\");\\n\\n        uint result;\\n        uint memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0, \\\"RLPDecoder toBytes invalid length\\\");\\n\\n        uint offset = _payloadOffset(item.memPtr);\\n        require(item.len >= offset, \\\"RLPDecoder: invalid RLP item offset size\\\");\\n        uint len = item.len - offset; // data length\\n        bytes memory result = new bytes(len);\\n\\n        uint destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr + offset, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) internal pure returns (uint) {\\n        if (item.len == 0) return 0;\\n\\n        uint count = 0;\\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint memPtr) private pure returns (uint) {\\n        uint itemLen;\\n        uint byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\\n        else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\\n        uint byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) return 0;\\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\\n        else if (byte0 < LIST_SHORT_START)\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        else return byte0 - (LIST_LONG_START - 1) + 1;\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(\\n        uint src,\\n        uint dest,\\n        uint len\\n    ) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint mask = 256**(WORD_SIZE - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8a04c67df135e410959ee6198785223703f152b49c9ced79c6847ee391026e58\",\"license\":\"Apache-2.0\"},\"contracts/utility/UltraLightNodeEVMDecoder.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./RLPDecode.sol\\\";\\n\\nlibrary UltraLightNodeEVMDecoder {\\n    using RLPDecode for RLPDecode.RLPItem;\\n    using RLPDecode for RLPDecode.Iterator;\\n\\n    struct Log {\\n        address contractAddress;\\n        bytes32 topicZero;\\n        bytes data;\\n    }\\n\\n    function getReceiptLog(bytes memory data, uint logIndex) internal pure returns (Log memory) {\\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(data).iterator();\\n        uint idx;\\n        while (it.hasNext()) {\\n            if (idx == 3) {\\n                return toReceiptLog(it.next().getItemByIndex(logIndex).toRlpBytes());\\n            } else it.next();\\n            idx++;\\n        }\\n        revert(\\\"no log index in receipt\\\");\\n    }\\n\\n    function toReceiptLog(bytes memory data) internal pure returns (Log memory) {\\n        RLPDecode.Iterator memory it = RLPDecode.toRlpItem(data).iterator();\\n        Log memory log;\\n\\n        uint idx;\\n        while (it.hasNext()) {\\n            if (idx == 0) {\\n                log.contractAddress = it.next().toAddress();\\n            } else if (idx == 1) {\\n                RLPDecode.RLPItem memory item = it.next().getItemByIndex(0);\\n                log.topicZero = bytes32(item.toUint());\\n            } else if (idx == 2) log.data = it.next().toBytes();\\n            else it.next();\\n            idx++;\\n        }\\n        return log;\\n    }\\n}\\n\",\"keccak256\":\"0xa5a921e346276438893241fb9719b074bed6e215d37e372f91b2712cb9f46567\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x6101006040526000805460ff191660031790553480156200001f57600080fd5b506040516200278e3803806200278e83398101604081905262000042916200009b565b606093841b6001600160601b031990811660805292841b831660a05260f09190911b6001600160f01b03191660c05290911b1660e052620000fe565b80516001600160a01b03811681146200009657600080fd5b919050565b60008060008060808587031215620000b1578384fd5b620000bc856200007e565b9350620000cc602086016200007e565b9250604085015161ffff81168114620000e3578283fd5b9150620000f3606086016200007e565b905092959194509250565b60805160601c60a05160601c60c05160f01c60e05160601c612635620001596000398061029b5280610874528061094352508061025352806107ca525080610213528061043452508061027752806103c952506126356000f3fe608060405234801561001057600080fd5b50600436106100df5760003560e01c80636c473aff1161008c578063be9d395e11610066578063be9d395e146101b1578063d633ad61146101c6578063e0cabadd146101ce578063ea455df9146101e1576100df565b80636c473aff1461017457806378d823f71461017c578063b71e0f7114610191576100df565b80635711c2a8116100bd5780635711c2a8146101375780635b056da5146101575780636348d2691461016c576100df565b80630f222e65146100e45780633fc18d4c1461010d57806347713b3914610122575b600080fd5b6100f76100f2366004611b32565b6101f4565b6040516101049190612393565b60405180910390f35b610115610211565b6040516101049190612059565b61012a610235565b60405161010491906123fb565b61014a610145366004611c23565b61023e565b60405161010491906120b5565b61015f610251565b60405161010491906123c2565b610115610275565b610115610299565b61018f61018a366004611d96565b6102bd565b005b6101a461019f366004611ba6565b6102cd565b60405161010491906122ee565b6101b96104ac565b60405161010491906120ac565b61012a6104d0565b6101a46101dc366004611c56565b6104d9565b61014a6101ef366004611c23565b6104ed565b6101fc61182c565b610208858585856104f8565b95945050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b60005460ff1681565b6060610249826106a7565b90505b919050565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b6102c88383836107c8565b505050565b6102d561184b565b60008211610318576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f906122b7565b60405180910390fd5b60008080808061032a888a018a611e83565b9450945094509450945060006103428b8484876104f8565b60208101519091507fe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6146103a2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f9061218f565b805160408201516000916103ba919089908c90610a59565b90506103c781878e6107c8565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16816060015173ffffffffffffffffffffffffffffffffffffffff1614156104325761042c8160c001516106a7565b60c08201525b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16816060015173ffffffffffffffffffffffffffffffffffffffff16141561049d576104978160c00151610b4f565b60c08201525b9b9a5050505050505050505050565b7fe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f681565b60005460ff1690565b6104e161184b565b61020885858585610a59565b606061024982610b4f565b61050061182c565b815184511461053b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f906120ea565b6000825111610576576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f90612223565b61057e611889565b606060005b845181101561062a5784818151811061059857fe5b60200260200101519150818051906020012088146105e2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f90612158565b6106088782815181106105f157fe5b602002602001015161060284610bf9565b90610c6d565b925060018551038110156106225761061f83610e29565b97505b600101610583565b50600061063b600361060285610f46565b9050600061065161064c8389610c6d565b610fd2565b905061065b61182c565b61066c6106678361107e565b610e29565b815261067f61066760006106028561107e565b60208201526106956106908361107e565b61112e565b60408201529998505050505050505050565b6020810151606090600160ff821614156107c1576000806000806000806000898060200190518101906106da9190611f08565b9750975097509750975097509750506000815111156107b957815160009015610704575060148201515b803b806107b65760008260405160200161071e9190612029565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815260208381018352600080855292519194509192610774928f928f928f928f928f928f928b9201612409565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190529c5061024c9b505050505050505050505050565b50505b505050505050505b5090919050565b7f000000000000000000000000000000000000000000000000000000000000000061ffff16836020015161ffff161461082d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f906121c6565b825160608401516040517fa466222200000000000000000000000000000000000000000000000000000000815260009273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169263a4662222926108a99291906004016123d1565b60c06040518083038186803b1580156108c157600080fd5b505afa1580156108d5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108f99190611cf8565b60a081015185516040517febfa08e900000000000000000000000000000000000000000000000000000000815292935060009273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169263ebfa08e99261097892899060040161207a565b604080518083038186803b15801561098f57600080fd5b505afa1580156109a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109c79190611a4b565b905082816020015114610a06576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f90612121565b816020015167ffffffffffffffff1681600001511015610a52576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f9061225a565b5050505050565b610a6161184b565b602085015160608601516068870151858801607c01519190610a816118a3565b610a8b818961125b565b50610a9b8160008c60888c611295565b506000610ab389610aad86601c61136f565b9061136f565b9050610abd6118a3565b610ac7818361125b565b50610ae360008d610ad98d609c6113e6565b8492919086611295565b506040805160e08101825261ffff808e16825298909816602089015267ffffffffffffffff909416938701939093525073ffffffffffffffffffffffffffffffffffffffff9093166060850152915160808401525060a082018490525160c08201529050949350505050565b606060008083806020019051810190610b689190611cb3565b9150915060008083511115610b7e575060148201515b73ffffffffffffffffffffffffffffffffffffffff8116610bf05760405161dead90600090610bb1908390602001612029565b60405160208183030381529060405290508084604051602001610bd59291906120c8565b6040516020818303038152906040529550505050505061024c565b50929392505050565b610c01611889565b602082018051835160009190911a908015801590610c22575060c060ff8316105b15610c5157600192909201917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff015b6040805180820190915290815260208101929092525092915050565b610c75611889565b610c7e83611461565b610cd3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260218152602001806125be6021913960400191505060405180910390fd5b610cdc8361149b565b8210610d4957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f524c50206974656d206f7574206f6620626f756e647300000000000000000000604482015290519081900360640190fd5b8251602084015190810190600090610d60906114f3565b60208601510190506000805b85811015610d8b57610d7d83611592565b928301929150600101610d6c565b50610d9582611592565b9050828183011115610e0857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f524c50206974656d206f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b60405180604001604052808281526020018381525093505050505b92915050565b805160009015801590610e3e57508151602110155b610ea957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f524c504465636f64657220746f55696e7420696e76616c6964206c656e677468604482015290519081900360640190fd5b6000610eb883602001516114f3565b90508083600001511015610f17576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260288152602001806125966028913960400191505060405180910390fd5b825160208085015183018051928490039291831015610f3d57826020036101000a820491505b50949350505050565b610f4e611889565b6000610f5d83602001516114f3565b60208401518451908201805192935060009290921a91908015801590610f86575060c060ff8416105b15610fb557600191909101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff015b604080518082019091529081526020810191909152949350505050565b610fda6118bd565b610fe382611461565b61104e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f524c504465636f646572206974657261746f72206973206e6f74206c69737400604482015290519081900360640190fd5b600061105d83602001516114f3565b60208085015160408051808201909152868152920190820152915050919050565b611086611889565b61108f82611667565b6110fa57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f524c504465636f646572206974657261746f7220686173206e6f206e65787400604482015290519081900360640190fd5b6020820151600061110a82611592565b80830160209586015260408051808201909152908152938401919091525090919050565b8051606090611188576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260218152602001806125df6021913960400191505060405180910390fd5b600061119783602001516114f3565b905080836000015110156111f6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260288152602001806125966028913960400191505060405180910390fd5b825181900360008167ffffffffffffffff8111801561121457600080fd5b506040519080825280601f01601f19166020018201604052801561123f576020820181803683370190505b5090506000816020019050610f3d84876020015101828561167c565b6112636118a3565b60208206156112785760208206602003820191505b506020828101829052604080518085526000815290920101905290565b61129d6118a3565b856020015182860111156112c7576112c7866112bf8860200151888601611703565b60020261171a565b6000808751805188602083010193508089870111156112e65788860182525b5050508484015b6020841061132a57805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090930192602091820191016112ed565b5181517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208690036101000a01908116901991909116179052508495945050505050565b6000828211156113e057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604482015290519081900360640190fd5b50900390565b60008282018381101561145a57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b9392505050565b80516000906114725750600061024c565b6020820151805160001a9060c08210156114915760009250505061024c565b5060019392505050565b80516000906114ac5750600061024c565b6000806114bc84602001516114f3565b602085015185519181019250015b808210156114ea576114db82611592565b600190930192909101906114ca565b50909392505050565b8051600090811a608081101561150d57600091505061024c565b60b8811080611528575060c08110801590611528575060f881105b1561153757600191505061024c565b60c0811015611569577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4a01905061024c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0a01905061024c565b80516000908190811a60808110156115ad5760019150611660565b60b88110156115e0577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8181019150611660565b60c081101561160d5760b78103600185019450806020036101000a85510460018201810193505050611660565b60f8811015611640577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4181019150611660565b60f78103600185019450806020036101000a855104600182018101935050505b5092915050565b80518051602091820151919092015191011190565b80611686576102c8565b5b602081106116c45782518252602092830192909101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001611687565b915181516020939093036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169216919091179052565b600081831115611714575081610e23565b50919050565b8151611726838361125b565b506117318382611737565b50505050565b61173f6118a3565b61145a838460000151518485516117546118a3565b825182111561176257600080fd5b8460200151828501111561178457611784856112bf8760200151878601611703565b6000808651805187602083010193508088870111156117a35787860182525b505050602084015b602084106117e857805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090930192602091820191016117ab565b5181517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208690036101000a019081169019919091161790525083949350505050565b6040805160608082018352600080835260208301529181019190915290565b6040805160e08101825260008082526020820181905291810182905260608082018390526080820181905260a082019290925260c081019190915290565b604051806040016040528060008152602001600081525090565b604051806040016040528060608152602001600081525090565b60405180604001604052806118d0611889565b8152602001600081525090565b803561024c8161254a565b805161024c8161254a565b600082601f830112611903578081fd5b81356020611918611913836124c0565b61249c565b82815281810190858301855b8581101561194d5761193b898684358b01016119b4565b84529284019290840190600101611924565b5090979650505050505050565b600082601f83011261196a578081fd5b8135602061197a611913836124c0565b8281528181019085830183850287018401881015611996578586fd5b855b8581101561194d57813584529284019290840190600101611998565b600082601f8301126119c4578081fd5b81356119d2611913826124de565b8181528460208386010111156119e6578283fd5b816020850160208301379081016020019190915292915050565b600082601f830112611a10578081fd5b8151611a1e611913826124de565b818152846020838601011115611a32578283fd5b611a4382602083016020870161251e565b949350505050565b600060408284031215611a5c578081fd5b6040516040810181811067ffffffffffffffff82111715611a7957fe5b604052825181526020928301519281019290925250919050565b600060c08284031215611aa4578081fd5b60405160c0810181811067ffffffffffffffff82111715611ac157fe5b8060405250809150825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a08201525092915050565b803561024c8161256f565b805161024c8161256f565b803561024c8161257f565b805161024c8161257f565b60008060008060808587031215611b47578384fd5b84359350602085013567ffffffffffffffff80821115611b65578485fd5b611b718883890161195a565b9450604087013593506060870135915080821115611b8d578283fd5b50611b9a878288016118f3565b91505092959194509250565b60008060008060608587031215611bbb578182fd5b84359350602085013567ffffffffffffffff80821115611bd9578384fd5b818701915087601f830112611bec578384fd5b813581811115611bfa578485fd5b886020828501011115611c0b578485fd5b95986020929092019750949560400135945092505050565b600060208284031215611c34578081fd5b813567ffffffffffffffff811115611c4a578182fd5b611a43848285016119b4565b60008060008060808587031215611c6b578182fd5b843567ffffffffffffffff811115611c81578283fd5b611c8d878288016119b4565b9450506020850135611c9e8161256f565b93969395505050506040820135916060013590565b60008060408385031215611cc5578182fd5b825167ffffffffffffffff811115611cdb578283fd5b611ce785828601611a00565b925050602083015190509250929050565b600060c08284031215611d09578081fd5b60405160c0810181811067ffffffffffffffff82111715611d2657fe5b6040528251611d348161256f565b81526020830151611d448161257f565b60208201526040830151611d578161254a565b6040820152611d6860608401611b11565b6060820152611d7960808401611b27565b6080820152611d8a60a084016118e8565b60a08201529392505050565b600080600060608486031215611daa578081fd5b833567ffffffffffffffff80821115611dc1578283fd5b9085019060e08288031215611dd4578283fd5b611dde60e061249c565b611de783611b06565b8152611df560208401611b06565b6020820152611e0660408401611b1c565b6040820152611e17606084016118dd565b6060820152608083013582811115611e2d578485fd5b611e39898286016119b4565b60808301525060a083013560a082015260c083013582811115611e5a578485fd5b611e66898286016119b4565b60c083015250976020870135975060409096013595945050505050565b600080600080600060a08688031215611e9a578283fd5b8535611ea58161256f565b945060208601359350604086013567ffffffffffffffff80821115611ec8578485fd5b611ed489838a016118f3565b94506060880135915080821115611ee9578283fd5b50611ef68882890161195a565b95989497509295608001359392505050565b6000806000806000806000806101c0898b031215611f24578586fd5b885160ff81168114611f34578687fd5b80985050602089015196506040890151955060608901519450611f5a8a60808b01611a4b565b9350611f698a60c08b01611a93565b925061018089015167ffffffffffffffff80821115611f86578384fd5b611f928c838d01611a00565b93506101a08b0151915080821115611fa8578283fd5b50611fb58b828c01611a00565b9150509295985092959890939650565b73ffffffffffffffffffffffffffffffffffffffff169052565b60008151808452611ff781602086016020860161251e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60609190911b7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000016815260140190565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff93909316835261ffff919091166020830152604082015260600190565b90815260200190565b60006020825261145a6020830184611fdf565b6000604082526120db6040830185611fdf565b90508260208301529392505050565b6020808252601c908201527f50726f6f664c69623a20696e76616c69642070726f6f662073697a6500000000604082015260600190565b6020808252601e908201527f50726f6f664c69623a20696e76616c6964207265636569707420726f6f740000604082015260600190565b6020808252601a908201527f50726f6f664c69623a20696e76616c696420686173686c696e6b000000000000604082015260600190565b6020808252601f908201527f50726f6f664c69623a207061636b6574206e6f74207265636f676e697a656400604082015260600190565b60208082526026908201527f50726f6f664c69623a20696e76616c69642064657374696e6174696f6e20636860408201527f61696e2049440000000000000000000000000000000000000000000000000000606082015260800190565b6020808252601d908201527f50726f6f664c69623a2070726f6f662073697a65206d757374203e2030000000604082015260600190565b60208082526028908201527f50726f6f664c69623a206e6f7420656e6f75676820626c6f636b20636f6e666960408201527f726d6174696f6e73000000000000000000000000000000000000000000000000606082015260800190565b6020808252601e908201527f50726f6f664c69623a20696e76616c696420616464726573732073697a650000604082015260600190565b60006020825261ffff8084511660208401528060208501511660408401525067ffffffffffffffff604084015116606083015260608301516123336080840182611fc5565b50608083015160e060a084015261234e610100840182611fdf565b905060a084015160c084015260c08401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08483030160e08501526102088282611fdf565b60006020825282516020830152602083015160408301526040830151606080840152611a436080840182611fdf565b61ffff91909116815260200190565b61ffff92909216825273ffffffffffffffffffffffffffffffffffffffff16602082015260400190565b60ff91909116815260200190565b60006101c060ff8b16835289602084015288604084015287606084015286516080840152602087015160a0840152855160c0840152602086015160e084015260408601516101008401526060860151610120840152608086015161014084015260a08601516101608401528061018084015261248781840186611fdf565b90508281036101a084015261049d8185611fdf565b60405181810167ffffffffffffffff811182821017156124b857fe5b604052919050565b600067ffffffffffffffff8211156124d457fe5b5060209081020190565b600067ffffffffffffffff8211156124f257fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b83811015612539578181015183820152602001612521565b838111156117315750506000910152565b73ffffffffffffffffffffffffffffffffffffffff8116811461256c57600080fd5b50565b61ffff8116811461256c57600080fd5b67ffffffffffffffff8116811461256c57600080fdfe524c504465636f6465723a20696e76616c696420524c50206974656d206f66667365742073697a65524c504465636f646572206974657261746f72206973206e6f742061206c697374524c504465636f64657220746f427974657320696e76616c6964206c656e677468a2646970667358221220de367aaacca8ca6e5e6f0304b952713d201f340decdfa89305cdebe80e97d21664736f6c63430007060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100df5760003560e01c80636c473aff1161008c578063be9d395e11610066578063be9d395e146101b1578063d633ad61146101c6578063e0cabadd146101ce578063ea455df9146101e1576100df565b80636c473aff1461017457806378d823f71461017c578063b71e0f7114610191576100df565b80635711c2a8116100bd5780635711c2a8146101375780635b056da5146101575780636348d2691461016c576100df565b80630f222e65146100e45780633fc18d4c1461010d57806347713b3914610122575b600080fd5b6100f76100f2366004611b32565b6101f4565b6040516101049190612393565b60405180910390f35b610115610211565b6040516101049190612059565b61012a610235565b60405161010491906123fb565b61014a610145366004611c23565b61023e565b60405161010491906120b5565b61015f610251565b60405161010491906123c2565b610115610275565b610115610299565b61018f61018a366004611d96565b6102bd565b005b6101a461019f366004611ba6565b6102cd565b60405161010491906122ee565b6101b96104ac565b60405161010491906120ac565b61012a6104d0565b6101a46101dc366004611c56565b6104d9565b61014a6101ef366004611c23565b6104ed565b6101fc61182c565b610208858585856104f8565b95945050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b60005460ff1681565b6060610249826106a7565b90505b919050565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b6102c88383836107c8565b505050565b6102d561184b565b60008211610318576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f906122b7565b60405180910390fd5b60008080808061032a888a018a611e83565b9450945094509450945060006103428b8484876104f8565b60208101519091507fe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f6146103a2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f9061218f565b805160408201516000916103ba919089908c90610a59565b90506103c781878e6107c8565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16816060015173ffffffffffffffffffffffffffffffffffffffff1614156104325761042c8160c001516106a7565b60c08201525b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16816060015173ffffffffffffffffffffffffffffffffffffffff16141561049d576104978160c00151610b4f565b60c08201525b9b9a5050505050505050505050565b7fe8d23d927749ec8e512eb885679c2977d57068839d8cca1a85685dbbea0648f681565b60005460ff1690565b6104e161184b565b61020885858585610a59565b606061024982610b4f565b61050061182c565b815184511461053b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f906120ea565b6000825111610576576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f90612223565b61057e611889565b606060005b845181101561062a5784818151811061059857fe5b60200260200101519150818051906020012088146105e2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f90612158565b6106088782815181106105f157fe5b602002602001015161060284610bf9565b90610c6d565b925060018551038110156106225761061f83610e29565b97505b600101610583565b50600061063b600361060285610f46565b9050600061065161064c8389610c6d565b610fd2565b905061065b61182c565b61066c6106678361107e565b610e29565b815261067f61066760006106028561107e565b60208201526106956106908361107e565b61112e565b60408201529998505050505050505050565b6020810151606090600160ff821614156107c1576000806000806000806000898060200190518101906106da9190611f08565b9750975097509750975097509750506000815111156107b957815160009015610704575060148201515b803b806107b65760008260405160200161071e9190612029565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815260208381018352600080855292519194509192610774928f928f928f928f928f928f928b9201612409565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190529c5061024c9b505050505050505050505050565b50505b505050505050505b5090919050565b7f000000000000000000000000000000000000000000000000000000000000000061ffff16836020015161ffff161461082d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f906121c6565b825160608401516040517fa466222200000000000000000000000000000000000000000000000000000000815260009273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169263a4662222926108a99291906004016123d1565b60c06040518083038186803b1580156108c157600080fd5b505afa1580156108d5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108f99190611cf8565b60a081015185516040517febfa08e900000000000000000000000000000000000000000000000000000000815292935060009273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169263ebfa08e99261097892899060040161207a565b604080518083038186803b15801561098f57600080fd5b505afa1580156109a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109c79190611a4b565b905082816020015114610a06576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f90612121565b816020015167ffffffffffffffff1681600001511015610a52576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161030f9061225a565b5050505050565b610a6161184b565b602085015160608601516068870151858801607c01519190610a816118a3565b610a8b818961125b565b50610a9b8160008c60888c611295565b506000610ab389610aad86601c61136f565b9061136f565b9050610abd6118a3565b610ac7818361125b565b50610ae360008d610ad98d609c6113e6565b8492919086611295565b506040805160e08101825261ffff808e16825298909816602089015267ffffffffffffffff909416938701939093525073ffffffffffffffffffffffffffffffffffffffff9093166060850152915160808401525060a082018490525160c08201529050949350505050565b606060008083806020019051810190610b689190611cb3565b9150915060008083511115610b7e575060148201515b73ffffffffffffffffffffffffffffffffffffffff8116610bf05760405161dead90600090610bb1908390602001612029565b60405160208183030381529060405290508084604051602001610bd59291906120c8565b6040516020818303038152906040529550505050505061024c565b50929392505050565b610c01611889565b602082018051835160009190911a908015801590610c22575060c060ff8316105b15610c5157600192909201917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff015b6040805180820190915290815260208101929092525092915050565b610c75611889565b610c7e83611461565b610cd3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260218152602001806125be6021913960400191505060405180910390fd5b610cdc8361149b565b8210610d4957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f524c50206974656d206f7574206f6620626f756e647300000000000000000000604482015290519081900360640190fd5b8251602084015190810190600090610d60906114f3565b60208601510190506000805b85811015610d8b57610d7d83611592565b928301929150600101610d6c565b50610d9582611592565b9050828183011115610e0857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f524c50206974656d206f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b60405180604001604052808281526020018381525093505050505b92915050565b805160009015801590610e3e57508151602110155b610ea957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f524c504465636f64657220746f55696e7420696e76616c6964206c656e677468604482015290519081900360640190fd5b6000610eb883602001516114f3565b90508083600001511015610f17576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260288152602001806125966028913960400191505060405180910390fd5b825160208085015183018051928490039291831015610f3d57826020036101000a820491505b50949350505050565b610f4e611889565b6000610f5d83602001516114f3565b60208401518451908201805192935060009290921a91908015801590610f86575060c060ff8416105b15610fb557600191909101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff015b604080518082019091529081526020810191909152949350505050565b610fda6118bd565b610fe382611461565b61104e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f524c504465636f646572206974657261746f72206973206e6f74206c69737400604482015290519081900360640190fd5b600061105d83602001516114f3565b60208085015160408051808201909152868152920190820152915050919050565b611086611889565b61108f82611667565b6110fa57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f524c504465636f646572206974657261746f7220686173206e6f206e65787400604482015290519081900360640190fd5b6020820151600061110a82611592565b80830160209586015260408051808201909152908152938401919091525090919050565b8051606090611188576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260218152602001806125df6021913960400191505060405180910390fd5b600061119783602001516114f3565b905080836000015110156111f6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260288152602001806125966028913960400191505060405180910390fd5b825181900360008167ffffffffffffffff8111801561121457600080fd5b506040519080825280601f01601f19166020018201604052801561123f576020820181803683370190505b5090506000816020019050610f3d84876020015101828561167c565b6112636118a3565b60208206156112785760208206602003820191505b506020828101829052604080518085526000815290920101905290565b61129d6118a3565b856020015182860111156112c7576112c7866112bf8860200151888601611703565b60020261171a565b6000808751805188602083010193508089870111156112e65788860182525b5050508484015b6020841061132a57805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090930192602091820191016112ed565b5181517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208690036101000a01908116901991909116179052508495945050505050565b6000828211156113e057604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604482015290519081900360640190fd5b50900390565b60008282018381101561145a57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b9392505050565b80516000906114725750600061024c565b6020820151805160001a9060c08210156114915760009250505061024c565b5060019392505050565b80516000906114ac5750600061024c565b6000806114bc84602001516114f3565b602085015185519181019250015b808210156114ea576114db82611592565b600190930192909101906114ca565b50909392505050565b8051600090811a608081101561150d57600091505061024c565b60b8811080611528575060c08110801590611528575060f881105b1561153757600191505061024c565b60c0811015611569577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4a01905061024c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0a01905061024c565b80516000908190811a60808110156115ad5760019150611660565b60b88110156115e0577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8181019150611660565b60c081101561160d5760b78103600185019450806020036101000a85510460018201810193505050611660565b60f8811015611640577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4181019150611660565b60f78103600185019450806020036101000a855104600182018101935050505b5092915050565b80518051602091820151919092015191011190565b80611686576102c8565b5b602081106116c45782518252602092830192909101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001611687565b915181516020939093036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169216919091179052565b600081831115611714575081610e23565b50919050565b8151611726838361125b565b506117318382611737565b50505050565b61173f6118a3565b61145a838460000151518485516117546118a3565b825182111561176257600080fd5b8460200151828501111561178457611784856112bf8760200151878601611703565b6000808651805187602083010193508088870111156117a35787860182525b505050602084015b602084106117e857805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090930192602091820191016117ab565b5181517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208690036101000a019081169019919091161790525083949350505050565b6040805160608082018352600080835260208301529181019190915290565b6040805160e08101825260008082526020820181905291810182905260608082018390526080820181905260a082019290925260c081019190915290565b604051806040016040528060008152602001600081525090565b604051806040016040528060608152602001600081525090565b60405180604001604052806118d0611889565b8152602001600081525090565b803561024c8161254a565b805161024c8161254a565b600082601f830112611903578081fd5b81356020611918611913836124c0565b61249c565b82815281810190858301855b8581101561194d5761193b898684358b01016119b4565b84529284019290840190600101611924565b5090979650505050505050565b600082601f83011261196a578081fd5b8135602061197a611913836124c0565b8281528181019085830183850287018401881015611996578586fd5b855b8581101561194d57813584529284019290840190600101611998565b600082601f8301126119c4578081fd5b81356119d2611913826124de565b8181528460208386010111156119e6578283fd5b816020850160208301379081016020019190915292915050565b600082601f830112611a10578081fd5b8151611a1e611913826124de565b818152846020838601011115611a32578283fd5b611a4382602083016020870161251e565b949350505050565b600060408284031215611a5c578081fd5b6040516040810181811067ffffffffffffffff82111715611a7957fe5b604052825181526020928301519281019290925250919050565b600060c08284031215611aa4578081fd5b60405160c0810181811067ffffffffffffffff82111715611ac157fe5b8060405250809150825181526020830151602082015260408301516040820152606083015160608201526080830151608082015260a083015160a08201525092915050565b803561024c8161256f565b805161024c8161256f565b803561024c8161257f565b805161024c8161257f565b60008060008060808587031215611b47578384fd5b84359350602085013567ffffffffffffffff80821115611b65578485fd5b611b718883890161195a565b9450604087013593506060870135915080821115611b8d578283fd5b50611b9a878288016118f3565b91505092959194509250565b60008060008060608587031215611bbb578182fd5b84359350602085013567ffffffffffffffff80821115611bd9578384fd5b818701915087601f830112611bec578384fd5b813581811115611bfa578485fd5b886020828501011115611c0b578485fd5b95986020929092019750949560400135945092505050565b600060208284031215611c34578081fd5b813567ffffffffffffffff811115611c4a578182fd5b611a43848285016119b4565b60008060008060808587031215611c6b578182fd5b843567ffffffffffffffff811115611c81578283fd5b611c8d878288016119b4565b9450506020850135611c9e8161256f565b93969395505050506040820135916060013590565b60008060408385031215611cc5578182fd5b825167ffffffffffffffff811115611cdb578283fd5b611ce785828601611a00565b925050602083015190509250929050565b600060c08284031215611d09578081fd5b60405160c0810181811067ffffffffffffffff82111715611d2657fe5b6040528251611d348161256f565b81526020830151611d448161257f565b60208201526040830151611d578161254a565b6040820152611d6860608401611b11565b6060820152611d7960808401611b27565b6080820152611d8a60a084016118e8565b60a08201529392505050565b600080600060608486031215611daa578081fd5b833567ffffffffffffffff80821115611dc1578283fd5b9085019060e08288031215611dd4578283fd5b611dde60e061249c565b611de783611b06565b8152611df560208401611b06565b6020820152611e0660408401611b1c565b6040820152611e17606084016118dd565b6060820152608083013582811115611e2d578485fd5b611e39898286016119b4565b60808301525060a083013560a082015260c083013582811115611e5a578485fd5b611e66898286016119b4565b60c083015250976020870135975060409096013595945050505050565b600080600080600060a08688031215611e9a578283fd5b8535611ea58161256f565b945060208601359350604086013567ffffffffffffffff80821115611ec8578485fd5b611ed489838a016118f3565b94506060880135915080821115611ee9578283fd5b50611ef68882890161195a565b95989497509295608001359392505050565b6000806000806000806000806101c0898b031215611f24578586fd5b885160ff81168114611f34578687fd5b80985050602089015196506040890151955060608901519450611f5a8a60808b01611a4b565b9350611f698a60c08b01611a93565b925061018089015167ffffffffffffffff80821115611f86578384fd5b611f928c838d01611a00565b93506101a08b0151915080821115611fa8578283fd5b50611fb58b828c01611a00565b9150509295985092959890939650565b73ffffffffffffffffffffffffffffffffffffffff169052565b60008151808452611ff781602086016020860161251e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60609190911b7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000016815260140190565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b73ffffffffffffffffffffffffffffffffffffffff93909316835261ffff919091166020830152604082015260600190565b90815260200190565b60006020825261145a6020830184611fdf565b6000604082526120db6040830185611fdf565b90508260208301529392505050565b6020808252601c908201527f50726f6f664c69623a20696e76616c69642070726f6f662073697a6500000000604082015260600190565b6020808252601e908201527f50726f6f664c69623a20696e76616c6964207265636569707420726f6f740000604082015260600190565b6020808252601a908201527f50726f6f664c69623a20696e76616c696420686173686c696e6b000000000000604082015260600190565b6020808252601f908201527f50726f6f664c69623a207061636b6574206e6f74207265636f676e697a656400604082015260600190565b60208082526026908201527f50726f6f664c69623a20696e76616c69642064657374696e6174696f6e20636860408201527f61696e2049440000000000000000000000000000000000000000000000000000606082015260800190565b6020808252601d908201527f50726f6f664c69623a2070726f6f662073697a65206d757374203e2030000000604082015260600190565b60208082526028908201527f50726f6f664c69623a206e6f7420656e6f75676820626c6f636b20636f6e666960408201527f726d6174696f6e73000000000000000000000000000000000000000000000000606082015260800190565b6020808252601e908201527f50726f6f664c69623a20696e76616c696420616464726573732073697a650000604082015260600190565b60006020825261ffff8084511660208401528060208501511660408401525067ffffffffffffffff604084015116606083015260608301516123336080840182611fc5565b50608083015160e060a084015261234e610100840182611fdf565b905060a084015160c084015260c08401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08483030160e08501526102088282611fdf565b60006020825282516020830152602083015160408301526040830151606080840152611a436080840182611fdf565b61ffff91909116815260200190565b61ffff92909216825273ffffffffffffffffffffffffffffffffffffffff16602082015260400190565b60ff91909116815260200190565b60006101c060ff8b16835289602084015288604084015287606084015286516080840152602087015160a0840152855160c0840152602086015160e084015260408601516101008401526060860151610120840152608086015161014084015260a08601516101608401528061018084015261248781840186611fdf565b90508281036101a084015261049d8185611fdf565b60405181810167ffffffffffffffff811182821017156124b857fe5b604052919050565b600067ffffffffffffffff8211156124d457fe5b5060209081020190565b600067ffffffffffffffff8211156124f257fe5b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b83811015612539578181015183820152602001612521565b838111156117315750506000910152565b73ffffffffffffffffffffffffffffffffffffffff8116811461256c57600080fd5b50565b61ffff8116811461256c57600080fd5b67ffffffffffffffff8116811461256c57600080fdfe524c504465636f6465723a20696e76616c696420524c50206974656d206f66667365742073697a65524c504465636f646572206974657261746f72206973206e6f742061206c697374524c504465636f64657220746f427974657320696e76616c6964206c656e677468a2646970667358221220de367aaacca8ca6e5e6f0304b952713d201f340decdfa89305cdebe80e97d21664736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3071,
        "contract": "contracts/MPTValidatorV4.sol:MPTValidatorV4",
        "label": "utilsVersion",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      }
    ],
    "types": {
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}